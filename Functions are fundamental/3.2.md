### 3.2 Declarations

在js中，声明函数变量和声明数字变量是一样的，函数变量的使用位置和数字、字符变量也是一样的。函数字面值由以下4部分组成：

1. _function_ 关键字
2. 可选的函数名，必须满足变量命名规则
3. 由逗号分隔的参数列表，列表可以为空，参数名必须是合法的变量名。列表用左右括号闭合
4. 用花括号包括的函数体。函数体内是一系列的js表达式

函数名是可选的对于某些开发者来说有些吃惊。对于不需要用名字引用的函数来说，js无需设置函数名。

如果一个函数有名字，那么这个名字在声明它的整个作用域里都是有效的。另外，如果函数在最上层声明，那么在*window*对象中，就会有一个以这个函数名为属性名的属性，指向该函数。

最后，所有函数都有一个_name_属性，值为它的名字。如果没有声明函数名，那么它的值为空字符串。废话少说，我们下面上例子：

** Listing 3.1 Proving things about the way that functions are declared **
```javascript
      function isNimble(){ return true; }                            //#1 定义有名函数，该函数在整个作用域中有效，并且隐式的成为了window对象的属性。

      assert(typeof window.isNimble === "function",                  //#2 第一个测试检查window对象是否包含了isNimble属性，第二个测试检查函数的名字是否正确
            "isNimble() defined");
      assert(isNimble.name === "isNimble",
            "isNimble() has a name");


      var canFly = function(){ return true; };                       //#3 通过canFly引用一个匿名函数，该变量会成为window的属性，但是函数名未设置。

      assert(typeof window.canFly === "function",                    //#4 检测canFly是否在window对象中，同时函数名是否为空（不是null）
             "canFly() defined");
      assert(canFly.name === "",
             "canFly() has no name");


      window.isDeadly = function(){ return true; };                  //#5 直接创建window属性，指向匿名函数

      assert(typeof window.isDeadly === "function",                  //#6 与#4类似，我们可以检查它的函数名也是空字符串。
             "isDeadly() defined");

      function outer(){                                              //#7 在outer函数中定义inner函数，检查inner函数在它声明前后是都可以访问的，即在声明它的整个作用域中有效。同时inner并没有加入到window中。
        assert(typeof inner === "function",
               "inner() in scope before declaration");
        function inner(){}
        assert(typeof inner === "function",
              "inner() in scope after declaration");
        assert(window.inner === undefined,
               "inner() not in global scope");
      }

      outer();                                                       //#8 inner依然不在window中。
      assert(window.inner === undefined,
             "inner() still not in global scope");

      window.wieldsSword = function swingsSword() { return true; };  //#9 引用函数的变量名和函数自己的名字之间没有任何关系。

      assert(window.wieldsSword.name === 'swingsSword',
             "wieldSword's real name is swingsSword");
```
以上例子用3种方式定义了函数：
* isNimble被定义为一个有名字的函数，这是程序员最常见的用法，但却不是js最常用的。
* canFly和isDeadly类似，都是一个引用匿名函数的变量。它们和isNimble在用法上一样。不同的是它们的函数名是空字符串。
* wieldsSword引用的则是一个有名字的函数，从中可以更明显看到变量名和函数名没有关系。

我们通过asert判断我们关于函数的认识是否正确，以上代码的执行结果如下：

<img src="https://github.com/flybywind/SecretsOfJavaScriptNinja/blob/master/img/fig3.4.jpg" alt="figure 3.4 通过测试检验我们的结论都是对的" width="200px">
