### 3.3 Invocations

函数的执行方式严重影响了函数内部代码的功能，尤其是 _this_ 指针。弄清楚这一点将使我们向忍者的水平更进一步。

有4种执行函数的方式，每一种都有细微不同：

* 作为函数本身调用，这是最基本的。
* 作为方法调用，调用过程和对象结合起来，实现面向对象编程。
* 作为构造函数调用，此时新的对象将被创建。
* 通过它的 _apply_ 或 _call_ 方法，这个有些麻烦，我们后面遇到再说。

除了最后一种情况，所有函数的调用方法都是表达式后跟括号，括号中是参数列表，表达式经过计算必须是指向函数的引用。
如下：

```Javascript
expressions(arg1, arg2)
```

下面我们先看看函数对参数的处理。

#### 3.3.1 From arguments to function parameters

调用时括号中的变量（即实参），将按照函数声明时的顺序赋值给各个参数（即形参），第一个实参赋值给第一个形参，第二个实参赋值给第二个形参。以此类推。

如果实参和形参的数目不一致，js不会报错，而是按照如下方法处理：

* 如果实参多余形参，多余的实参将被丢弃，不会影响其他形参。例如函数声明为`function foo(a,b,c){...}`，调用时为`foo(1,2,3,4,5)`，那么在函数中`a==1, b==2, c==3`，后面我们会看到，我们有其他方式获得4和5 。
* 如果实参少于形参，那么多余的形参值为`undefined`

另外，在每个函数内部，都有2个隐式参数： _arguments_ 和 _this_ 。他们不能出现在形参列表中，但在函数作用域内有效。他们能像一般形参那样使用。

下面我们分别看看这2个参数的作用。

##### THE ARGUMENTS PARAMETER

_arguments_ 包含所有传入的实参对象，它有一个 _length_ 属性，可以通过 _arguments[0]_、 _arguments[1]_、 _arguments[2]_ 这样来访问各个实参，还能用 _for_ 进行遍历，但是切记，它不是 _array_ ！有些array方法它不支持。它只是一个类似array的对象而已。

_this_ 指针就更有趣了。

##### THE “THIS” PARAMETER

this又成为函数上下文(function context)，指向函数调用时某个和函数相关联的对象。

在作为对象方法调用时，它指向所属的实例对象，这点和面对对象编程语言一样。但是在其他情况下，this的含义就完全由调用方法决定。因此this更应该被称为 _调用上下文_ ，但是从来没人咨询过本人对该变量命名的意见 :disappointed: 。

我们将分析以上4种调用方法的差异，从中你会发现，最主要的不同就是this所指对象的不同。我们在3.4节会重点讲述this指针，下面我们先看看函数如何调用。

#### 3.3.2 Invocation as a function

以函数的形式调用？函数不以函数形式调用还能怎么调用？刚才我们看到，函数有4种调用方式，下面我们先看最基本的这个。

当函数用括号调用时，就是以函数形式调用。例如：

```javascript
function ninja(){};
ninja();
var samurai = function(){};
samurai();
```

此时this指向全局作用域，即window对象。所以，这种调用方式其实是“作为方法调用”的一个特例。

#### 3.3.3 Invocation as a method

当函数赋值为一个对象的属性，并且通过该属性进行调用时，就是作为方法进行调用。如下：

```javascript
var o = {};
o.whatever = function(){};
o.whatever();
```

此时，在函数内部，可以通过this引用对象o，这是面向对象编程的基础，也是js对面向对象机制提供的支持。

而“作为函数调用”时，函数会隐式成为window的对象，函数 _属于_ window，函数上下文就指向window，所以二者在原理上完全一样，只是调用时window对象可以略去。

> 译者注：在listing3.2中，函数inner的this也指向window，但是inner不属于window，这点就和“作为方法调用”不同了。

下面我们通过例子来看看二者的区别：

**Listing 3.3 Illustrating the differences between function and method invocations**
```javascript
<script type="text/javascript">

  function creep(){ return this; }                     //#1 通过返回的this，检查函数上下文的区别。
  assert(creep() === window,                           //#1 this指向window对象
         "Creeping in the window");                    //#1

  var sneak = creep;                                   //#3 同1，sneak只是指向creep的引用
  assert(sneak() === window,                           //#4
         "Sneaking in the window");                    //#4

  var ninja1 = {                                       //#5 改变了上下文
    skulk: creep                                       //#5
  };
  assert(ninja1.skulk() === ninja1,                    //#6 this指向ninja1
         "The 1st ninja is skulking");                 //#6

  var ninja2 = {                                       //#7
    skulk: creep                                       //#7
  };
  assert(ninja2.skulk() === ninja2,                    //#8  同5、6，this指向ninja2
         "The 2nd ninja is skulking");                 //#8
</script>
```

测试结果如下：

<img src="https://github.com/flybywind/SecretsOfJavaScriptNinja/blob/master/img/fig3.6.jpg" alt="figure 3.6" width="300px">

以上测试再次体现了函数的一等公民地位，同时可以看到，在作为函数调用时，this都指向window，在作为方法调用时，this指向具体对象。在#5中，我们创建了ninja1对象，并且给了它一个skulk属性，该属性是一个指向creep的引用。注意此时creep并没有成为ninja1的方法，它和ninja1没有任何关系，creep的this总是指向window。但是在调用ninja1.skulk()的时候，this返回的是ninja1 。

这在设计js的面向对象编程时至关重要，this总是指向方法所属的对象。

为了进一步确认我们的判断，我们有创建了ninja2，结果同样符合预期。

注意，在以上4种情况下，我们其实都是引用了同一个函数，但是this所指的对象却随着调用环境的改变而改变了，而不是在声明时决定的。

在以上测试中，我们不需要为ninja1、ninja2的skulk属性分别创建不同的函数，只要引用同一个函数即可，极大提高了代码复用率，所以这是一个非常强大的功能。当然以上测试还是有些啰嗦，因为ninja1和2的结构完全一样，我们重复编码了。

下面我们介绍构造函数，进一步精简我们的代码。

#### 3.3.4 Invocation as a constructor
