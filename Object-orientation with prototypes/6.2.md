### 6.2 The gotchas!（陷阱）

前2个陷阱比较简单，而且不容易遇到我就一笔带过了。

1. 不要扩展**Object**对象。因为扩展Object之后，会使得for循环多遇到一个元素，尽管可以通过`this.hasOwnProperty(i)`来判断，还是很不方便
2. 不要扩展**Number**对象。否则会抛出异常

#### 6.2.3 Subclassing native objects

下面讲第三个:继承Array类，这个遇见的概率更大些。而且使用的技巧也容易推广。
但是如果我们这样写：

```javascript
       QUnit.test(
            "Simulating Array functionality but without the true subclassing",
            function(assert) {
                function MyArray0() {}
                MyArray0.prototype = new Array();
                var mine = new MyArray0();
                mine.push(1, 2, 3);
                assert.deepEqual(mine.length, 3,
                    "All the items are in our sub-classed array.");
                assert.deepEqual(mine[0], 1,
                    "first element is 1");
                assert.deepEqual(mine[1], 2,
                    "first element is 2");
                assert.deepEqual(mine[2], 3,
                    "first element is 3");
                assert.ok(mine instanceof Array,
                    "Verify that we implement Array functionality.");
            })
```

以上代码在大部分浏览器上运行正常，除了IE（又是它！）。因为IE的length属性非常特殊。可以看到，只有第一个测试失败了。
![继承Array失败](https://github.com/flybywind/SecretsOfJavaScriptNinja/blob/master/img/6.16_0.jpg)

为了解决以上问题，我们需要分别绑定每个方法：

*Listing 6.15 Simulating Array functionality but without the true subclassing*

```javascript
       QUnit.test(
            "Simulating Array functionality but without the true subclassing",
            function(assert) {
                function MyArray() {}
                // Defines a new class with a prototyped length property￼￼￼
                MyArray.prototype.length = 0;
                (function() {
                    var methods = ['push', 'pop', 'shift', 'unshift',
                        'slice', 'splice', 'join'
                    ];
                    // Copies selected array functionality￼
                    for (var i = 0; i < methods.length; i++)(function(name) {
                        MyArray.prototype[name] = function() {
                            return Array.prototype[name].apply(this, arguments);
                        };
                    })(methods[i]);
                })();
                var mine = new MyArray();
                mine.push(1, 2, 3);
                assert.deepEqual(mine.length, 3,
                    "All the items are on our sub-classed array.");
                assert.deepEqual(mine[0], 1,
                    "first element is 1");
                assert.deepEqual(mine[1], 2,
                    "first element is 2");
                assert.deepEqual(mine[2], 3,
                    "first element is 3");
                assert.ok(!(mine instanceof Array),
                    "We aren't subclassing Array, though.");

            });
```
   
上例中，我们只是给MyArray的原型定义了一个length，因为他是唯一可变的属性，而且IE没有提供该属性。然后我们使用immediate function和第四章学到的apply()技巧给MyArray绑定每个方法。
> 注意这里我们并没有继承Array，只是模拟了一个

#### 6.2.4 Instantiation issues
