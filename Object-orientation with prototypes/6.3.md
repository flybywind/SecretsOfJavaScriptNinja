### 6.3 Writing class-like code

尽管javascript提供了一套继承/类体系，但是用法和其他语言相差甚远。为了简化继承体系，方便多数用户使用，我们需要设计一套和其他语言类似的继承系统。我们希望系统具有如下特性：

* 简化构造函数和原型语法
* 简化原型继承
* 子类可以访问被覆盖的父类方法

提供这些功能的第三方库很多，其中最杰出的当属base2和Prototype。尽管它们还提供了很多其他特性，面向对象方法依然是它们的核心。在此我们将提炼出它们解决继承问题的方案，设计一套“面向对象科班出身”的同学非常熟悉的语法。

以下是设计完成的效果

*Listing 6.20 An example of somewhat classical-style inheritance syntax*
```javascript
    // 用我们即将设计出的subClass方法，从Object继承一个子类：Person
    var Person = Object.subClass({
        init: function(isDancing) {
            this.dancing = isDancing;
        },
        dance: function() {
            return this.dancing;
        }
    });
    // Ninja从Person继承
    var Ninja = Person.subClass({
    // 调用父类的init()
        init: function() {
            this._super(false);
        },
    // 调用父类的dance
        dance: function() {
            // 忍者的特殊行为：
            return this._super();
        },
        swingSword: function() {
            return true;
        }
    });
    var person = new Person(true);
    assert(person.dance(),
        "The person is dancing.");
    var ninja = new Ninja();
    assert(ninja.swingSword(),
        "The sword is swinging.");
    assert(!ninja.dance(),
        "The ninja is not dancing.");
    assert(person instanceof Person,
        "Person is a Person.");
    assert(ninja instanceof Ninja &&
           ninja instanceof Person,
        "Ninja is a Ninja and a Person.");
```

这段代码有几个点需要注意：

1. 在构造新类时，subClass会自动调用父类的构造函数。如上所示，Person继承自Object，Ninja继承自Person。
2. 子类的构造函数更加简单，我们只需要设计针对子类的init函数即可
3. 所有子类最终来自一个父类：Object
4. 最具有挑战性的就是如何实现_super函数。可以看到他会根据不同的上下文决定使用父类的哪个函数

下面这段代码实现了我们上面列出的所有要求。**它将让我们真正见识到“上忍”的境界，如果你开始没读懂，不要沮丧，它确实很难。**为了让大家分析起来更容易，我先把它们全部写出来，然后大家再一块一块的分析

**Listing 6.21 A subclassing method**
```javascript
(function() {
  var initializing = false,
      superPattern =  // Determine if functions can be serialized
        /xyz/.test(function() { xyz; }) ? /\b_super\b/ : /.*/;       //#1

  // Creates a new Class that inherits from this class
  Object.subClass = function(properties) {                           //#2
    var _super = this.prototype;

    // 初始化基类，但不调用它的init函数！
    initializing = true;                                              //#3
    var proto = new this();                                           //#3
    initializing = false;                                             //#3

    // 把新加的属性拷贝到父类原型实例里：
    for (var name in properties) {                                    //#4
      // 检查是否在父类中已经存在
      proto[name] = typeof properties[name] == "function" &&
                    typeof _super[name] == "function" &&
                    superPattern.test(properties[name]) ?
          (function(name, fn) {                                        //#5
            return function() {
              var tmp = this._super;

              // 增加一个_super方法，指向父类的对应函数
              this._super = _super[name];

              // _super函数只是暂用一下，尔后还原
              var ret = fn.apply(this, arguments);
              this._super = tmp;

              return ret;
            };
          })(name, properties[name]) :
          properties[name];
    }

    // The dummy class constructor
    function Class() {                                                   //#6
      // All construction is actually done in the init method
      if (!initializing && this.init)
        this.init.apply(this, arguments);
    }
    // Populate our constructed prototype object
    Class.prototype = proto;                                             //#7
    
    // Enforce the constructor to be what we expect
    Class.constructor = Class;                                           //#8

    // And make this class extendable
    Class.subClass = arguments.callee;                                   //#9

    return Class;
  };
})();
```

理解以上代码，最重要的是看懂super和初始化部分。不过直接看看你很难，下面我们就来一一讲解

#### 6.3.1 Checking for function serializability





