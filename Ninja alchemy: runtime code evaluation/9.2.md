### 9.2 Function “decompilation”大部分Javascript的实现都提供反编译能力。在之前的Chapter6中，我们称这种能力为"序列化"，不过反编译(decompile)也经常使用。多数情况下反编译是指把程序从字节形态重组成源代码，显然js不是这种情况。但是除了序列化，似乎找不到更好地词语，而且序列化也有它的语义问题。而de-evaluate也说起来容易让舌头打结。所以，我们最终决定使用反编译(decompile)，尽管可能不是很确切。反编译并没有像他听起来那么难，它是通过函数的toString实现的，下面我们来测试一下：*Listing 9.4 Decompiling a function into a string*```javascript<script type="text/javascript">  function test(a){ return a + a; }                    //#1 定义函数  assert(test.toString() ===                           //#2         "function test(a){ return a + a; }",          //#2         "Function decompiled");                       //#2 测试decompile</script>```有一点需要注意，**decompile返回的函数包括了所有空格！包括每行后面的部分。** 如果你拷贝以上代码，并且尝试加减空格，那么测试就会失败。反编译有很多用处，比如*Prototype*库中，用它来解析函数的参数名，下面就是一个简单示例：*Listing 9.5 A function for finding the argument names of a function*```javascript<script type="text/javascript">  function argumentNames(fn) {    var found = /^[\s\(]*function[^(]*\(\s*([^)]*?)\s*\)/   //#1                .exec(fn.toString());                       //#1 寻找形参    return found && found[1] ?                              //#2             found[1].split(/,\s*/) :                       //#2             [];                                            //#2 切分形参表  }  assert(argumentNames(function(){}).length === 0,          //#3 zero-arg函数         "Works on zero-arg functions.");  assert(argumentNames(function(x){})[0] === "x",           //#4 single-arg函数         "Single argument working.");  var results = argumentNames(function(a,b,c,d,e){});       //#5 multi-arg函数  assert(results[0] == 'a' &&         results[1] == 'b' &&         results[2] == 'c' &&         results[3] == 'd' &&         results[4] == 'e',         "Multiple arguments working!");</script>```以上几行代码尽管短，却使用了很多js的高级特性。尤其是寻找形参的部分（#1所示），它使用了正则和反编译。然后我们分别对无参、单参和多参函数进行了测试，都通过了。当然，需要注意的是，有些浏览器不支持反编译，尽管比较少，比如Opera mini就是其一。当然我们不希望通过判断浏览器的类型来决定js是否支持反编译，而是使用“特性模拟(feature simulation，将在11章讨论)”来测试一个浏览器是否支持反编译，如下所示：```javascriptvar FUNCTION_DECOMPILATION = /abc(.|\n)*xyz/.test(function(abc){xyz;}); assert(FUNCTION_DECOMPILATION,     "Function decompilation works in this browser");```其中我们随便创建了一个匿名函数，把它放在字符串上下文里，如果浏览器支持反编译，则会自动把该函数转换成字符串，匹配成功；否则失败。以上我们看到了很多代码解析的用法，下面我们来看看如何在实际应用中使用这些技巧。