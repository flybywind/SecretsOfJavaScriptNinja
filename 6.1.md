js的面向对象体系是以prototype为基石的。prototype就是一个特殊对象，在通过`new`操作符初始化的时候，prototype会附加(attach)到构造对象上，当引用对象属性时，js会在自有属性和prototype属性之间自动适配。【注：这个过程在书中称之为RECONCILING REFERENCES，即"引用适配"】。具体流程如下：

1. 当引用对象属性时，对象先检查自身是否有该属性，如果有就用它，否则...
2. 确定和对象关联的prototype，如果它有该属性，就用它，否则...
3. 返回undefined

以下2个例子会说明的更清楚：

*Listing 6.2 Observing the precedence of initialization activities*

```javascript
	<script type="text/javascript">
		function Ninja(){
			this.swung = false;			this.swingSword = function(){				return !this.swung;
			};
		}
		Ninja.prototype.swingSword = function(){
			return this.swung;
		};
		var ninja = new Ninja();		assert(ninja.swingSword(),			"调用自身方法，非prototype的方法.");		</script>
```

*Listing 6.3 Observing the behavior of changes to the prototype*


```javascript
	<script type="text/javascript">
	/* 
	  这个例子说明，prototype不仅仅是copy到对象上，而是附加（attach）到对象上，prototype在后面的修改也会影响之前声明的对象。 
	*/  		function Ninja(){    		this.swung = true;		}  		var ninja = new Ninja();  		Ninja.prototype.swingSword = function(){    		return this.swung;		};  		assert(ninja.swingSword(),        	 "尽管不是顺序声明，该方法也可以访问.");	</script>
```在后面我们会看到更复杂的情况，不过在这里我们知道这些就够了。
那么，js是如何访问prototype的呢？原来，js的每个对象都有一个constructor属性，constructor指向构造函数，所以constructor.prototype就是声明类时使用的原型。如下图所示：
![constructor.prototype](https://github.com/flybywind/SecretsOfJavaScriptNinja/blob/master/img/constuctor.prototype.jpg)

以listing 6.3为例，我们可以通过`ninja.constructor.prototype.swingSword`访问原型的函数。这也解释了为什么在对象构造完成后，再去修改原型依然可以影响原对象，因为原型是attach到对象上，不是单纯复制。这种无缝实时更新给了我们极大的权限和可扩展性，是其他语言上很少见到的。
